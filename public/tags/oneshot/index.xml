<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ONESHOT on Code World</title><link>https://arnab7070.github.io/tags/oneshot/</link><description>Recent content in ONESHOT on Code World</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 26 Jan 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://arnab7070.github.io/tags/oneshot/index.xml" rel="self" type="application/rss+xml"/><item><title>Sorting Algorithms One Shot</title><link>https://arnab7070.github.io/sections/dsa/sorting-algorithms/</link><pubDate>Thu, 26 Jan 2023 00:00:00 +0000</pubDate><guid>https://arnab7070.github.io/sections/dsa/sorting-algorithms/</guid><description>Bubble Sort Code void bubbleSort(int arr[], int n){ int totalComparision = 0; for(int i = 0; i &amp;lt; n-1; i++){ for(int j = 0; j &amp;lt; n-i-1; j++){ totalComparision++; if(arr[j] &amp;gt; arr[j+1]){ swap(arr[j],arr[j+1]); } } } cout&amp;lt;&amp;lt;&amp;#34;The sorted array will look like: &amp;#34;; print(arr,n); cout&amp;lt;&amp;lt;&amp;#34;Total number of comparisions required: &amp;#34;&amp;lt;&amp;lt;totalComparision&amp;lt;&amp;lt;endl; } Insertion Sort Code void insertionSort(int arr[], int n){ int totalComparision = 0; for(int i = 1; i &amp;lt; n; i++){ int current_element = arr[i]; int j = i-1; while(arr[j] &amp;gt; current_element &amp;amp;&amp;amp; j &amp;gt;= 0){ totalComparision++; arr[j+1] = arr[j]; j--; } arr[j+1] = current_element; } cout&amp;lt;&amp;lt;&amp;#34;The sorted array will look like: &amp;#34;; print(arr, n); cout&amp;lt;&amp;lt;&amp;#34;Total number of comparisions required: &amp;#34;&amp;lt;&amp;lt;totalComparision&amp;lt;&amp;lt;endl; } Selection Sort Code void selectionSort(int arr[], int n){ int totalComparision = 0; for(int i = 0; i &amp;lt; n-1; i++){ int minIndex = i; for(int j = i+1; j &amp;lt; n; j++){ totalComparision++; if(arr[minIndex] &amp;gt; arr[j]){ minIndex = j; } } swap(arr[i],arr[minIndex]); } cout&amp;lt;&amp;lt;&amp;#34;The sorted array will look like: &amp;#34;; print(arr, n); cout&amp;lt;&amp;lt;&amp;#34;Total number of comparisions required: &amp;#34;&amp;lt;&amp;lt;totalComparision&amp;lt;&amp;lt;endl; } Merge Sort Code void merge(int arr[], int start, int end){ int mid = (start+end)/2; int len1 = mid-start+1; int len2 = end-mid; int first[len1]; int second[len2]; //Now copy the elements int mainArrayIndex = start; for(int i = 0; i &amp;lt; len1; i++){ first[i] = arr[mainArrayIndex++]; } for(int i = 0; i &amp;lt; len2; i++){ second[i] = arr[mainArrayIndex++]; } //Merge 2 sorted array int index1 = 0, index2 = 0; mainArrayIndex = start; while(index1 &amp;lt; len1 &amp;amp;&amp;amp; index2 &amp;lt; len2){ if(first[index1] &amp;lt; second[index2]){ arr[mainArrayIndex++] = first[index1++]; } else{ arr[mainArrayIndex++] = second[index2++]; } } while(index1 &amp;lt; len1){ arr[mainArrayIndex++] = first[index1++]; } while(index2 &amp;lt; len2){ arr[mainArrayIndex++] = second[index2++]; } } void mergeSort(int arr[], int start, int end){ if(start &amp;gt;= end){ return; } int mid = (start+end)/2; mergeSort(arr, start, mid); mergeSort(arr, mid+1, end); merge(arr, start, end); } Heap Sort Code void heapify(int arr[], int n, int i){ int largest = i; int left = 2*i + 1; int right = 2*i + 2; if(left &amp;lt; n &amp;amp;&amp;amp; arr[left] &amp;gt; arr[largest]){ largest = left; } if(right &amp;lt; n &amp;amp;&amp;amp; arr[right] &amp;gt; arr[largest]){ largest = right; } if(i !</description></item><item><title>Priority Queue Operations</title><link>https://arnab7070.github.io/sections/dsa/priority-queue/</link><pubDate>Sun, 22 Jan 2023 00:00:00 +0000</pubDate><guid>https://arnab7070.github.io/sections/dsa/priority-queue/</guid><description>Some Basic Concepts A priority queue is a data structure that stores elements in a specific order based on their priority. Elements with higher priority are served before elements with lower priority.</description></item><item><title>1. Array Operations</title><link>https://arnab7070.github.io/sections/dsa/array-operations/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://arnab7070.github.io/sections/dsa/array-operations/</guid><description>Some Basic Concepts In C++, an array is a collection of items that are stored in a contiguous block of memory. The items can be of the same type or of different types, and the type of the items is specified when the array is declared.</description></item><item><title>2. Stack Operations</title><link>https://arnab7070.github.io/sections/dsa/stack-operations/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://arnab7070.github.io/sections/dsa/stack-operations/</guid><description>Some Basic Concepts A stack is a linear data structure that stores items in a Last-In/First-Out (LIFO) manner. In other words, the last item added to the stack will be the first one to be removed.</description></item><item><title>3. Queue Operations</title><link>https://arnab7070.github.io/sections/dsa/queue-operations/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://arnab7070.github.io/sections/dsa/queue-operations/</guid><description>Some Basic Concepts A queue is a linear data structure that follows the First In, First Out (FIFO) principle. In other words, the first element added to the queue will be the first one to be removed.</description></item><item><title>4. Circular Queue Operations</title><link>https://arnab7070.github.io/sections/dsa/circular-queue/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://arnab7070.github.io/sections/dsa/circular-queue/</guid><description>Benifits of Circular Queue A circular queue is a type of queue in which the last position is connected to the first position, so that the queue can be treated as a circular list.</description></item><item><title>5. Linked List Operations</title><link>https://arnab7070.github.io/sections/dsa/linked-list-operations/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://arnab7070.github.io/sections/dsa/linked-list-operations/</guid><description>Some Basic Concepts A singly linked list is a linear data structure that consists of a sequence of nodes, where each node contains a value and a pointer to the next node in the list.</description></item><item><title>6. Doubly Linked List</title><link>https://arnab7070.github.io/sections/dsa/doubly-linked-list/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://arnab7070.github.io/sections/dsa/doubly-linked-list/</guid><description>Some Basic Concepts A doubly linked list is a linear data structure that consists of a sequence of nodes, where each node contains a value and pointers to the previous and next nodes in the list.</description></item><item><title>7. Circular Linked List</title><link>https://arnab7070.github.io/sections/dsa/circular-linked-list/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://arnab7070.github.io/sections/dsa/circular-linked-list/</guid><description>Some Basic Concepts A circular linked list is a variation of a linked list in which the last node is connected to the first node, forming a circular list.</description></item><item><title>8. Infix To Postfix</title><link>https://arnab7070.github.io/sections/dsa/infix-to-postfix/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://arnab7070.github.io/sections/dsa/infix-to-postfix/</guid><description>Some Basic Concepts Infix notation is a common way of writing arithmetic expressions in which the operators are written between the operands, such as &amp;ldquo;3 + 4&amp;rdquo;.</description></item><item><title>9. Postfix Evaluation</title><link>https://arnab7070.github.io/sections/dsa/postfix-evaluation/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://arnab7070.github.io/sections/dsa/postfix-evaluation/</guid><description>Some Basic Concepts Postfix notation (also known as reverse Polish notation) is a way of writing arithmetic expressions in which the operands are written before the operators.</description></item><item><title>Binary Search Tree</title><link>https://arnab7070.github.io/sections/dsa/binary-search-tree/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://arnab7070.github.io/sections/dsa/binary-search-tree/</guid><description>Some Basic Concepts A binary search tree (BST) is a data structure that is used to store data in a sorted and searchable manner. It consists of nodes organized in a tree-like structure, where each node has at most two children.</description></item><item><title>Polynomial Addition</title><link>https://arnab7070.github.io/sections/dsa/polynomial-addition/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://arnab7070.github.io/sections/dsa/polynomial-addition/</guid><description>Now we will do an important question for interview preparation. We need to add two polynomials using Linked List. So let&amp;rsquo;s see how we can do it?</description></item><item><title>Queue Using Linked List</title><link>https://arnab7070.github.io/sections/dsa/queue-using-linked-list/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://arnab7070.github.io/sections/dsa/queue-using-linked-list/</guid><description>Some Basic Concepts A queue is a linear data structure that stores items in a First-In/First-Out (FIFO) manner. In other words, the first item added to the queue will be the first one to be removed.</description></item><item><title>Stack Using Linked List</title><link>https://arnab7070.github.io/sections/dsa/stack-using-linked-list/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://arnab7070.github.io/sections/dsa/stack-using-linked-list/</guid><description>Some Basic Concepts To implement a stack using a linked list, you will need to follow these steps:
Define a node data structure that has two fields: data: Stores the data for the current node.</description></item></channel></rss>